<!DOCTYPE html>
<html lang="en">
  <head>
    <title>VR Roller Coaster</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body { margin: 0; overflow: hidden; font-family: sans-serif; }
      #overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        pointer-events: none; z-index: 10;
      }
      .button-container { pointer-events: auto; margin: 10px; }
      button {
        padding: 15px 30px; font-size: 24px; cursor: pointer;
        background-color: #4caf50; color: white; border: none; border-radius: 8px;
      }
      button:hover { background-color: #45a049; }
      #message-display {
        color: white; font-size: 36px; margin-top: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <div class="button-container">
        <button id="startButton">Start Train</button>
      </div>
      <div id="message-display">Fly around or follow the coaster!</div>
    </div>

    <script type="module">
      import * as THREE from 'https://cdn.skypack.dev/three@0.128.0/build/three.module.js';
      import { VRButton } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/VRButton.js';
      import { FlyControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/FlyControls.js';
      import {
        RollerCoasterGeometry,
        TreesGeometry,
        SkyGeometry,
      } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/misc/RollerCoaster.js';

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);
      document.body.appendChild(VRButton.createButton(renderer));

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x88ccff);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(10, 15, 50);

      const controls = new FlyControls(camera, renderer.domElement);
      controls.movementSpeed = 30;
      controls.rollSpeed = Math.PI / 8;
      controls.autoForward = false;
      controls.dragToLook = true;

      const light = new THREE.HemisphereLight(0xfffff0, 0x444488, 1.2);
      scene.add(light);

      // Train cart (visible square box)
      const train = new THREE.Mesh(
        new THREE.BoxGeometry(2, 2, 2),
        new THREE.MeshStandardMaterial({ color: 0xff0000 })
      );
      train.castShadow = true;
      scene.add(train);

      // Coaster curve
      const trackPoints = [
        new THREE.Vector3(0, 10, 0), new THREE.Vector3(20, 30, 0), new THREE.Vector3(40, 50, 0),
        new THREE.Vector3(60, 45, -20), new THREE.Vector3(80, 25, -40), new THREE.Vector3(100, 15, -20),
        new THREE.Vector3(120, 20, 0), new THREE.Vector3(140, 25, 20), new THREE.Vector3(120, 30, 40),
        new THREE.Vector3(100, 35, 20), new THREE.Vector3(80, 40, 0), new THREE.Vector3(60, 35, -20),
        new THREE.Vector3(40, 20, -40), new THREE.Vector3(20, 15, -20), new THREE.Vector3(0, 10, 0),
      ];
      const curve = new THREE.CatmullRomCurve3(trackPoints, true);

      // Visible track
      const track = new RollerCoasterGeometry({ getPointAt: curve.getPointAt.bind(curve), getTangentAt: curve.getTangentAt.bind(curve) }, 1500);
      const trackMesh = new THREE.Mesh(track, new THREE.MeshPhongMaterial({ color: 0x333333, flatShading: true }));
      scene.add(trackMesh);

      // Ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(1000, 1000),
        new THREE.MeshLambertMaterial({ color: 0x228822 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);

      // Trees
      scene.add(new THREE.Mesh(
        new TreesGeometry(ground),
        new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide })
      ));

      // Sky
      scene.add(new THREE.Mesh(new SkyGeometry(), new THREE.MeshBasicMaterial({ color: 0xffffff })));

      // Coaster motion variables
      let currentVelocity = 0;
      let currentProgress = 0;
      let coasterState = 'stopped';

      const startButton = document.getElementById('startButton');
      const messageDisplay = document.getElementById('message-display');
      startButton.addEventListener('click', () => {
        if (coasterState === 'stopped') {
          coasterState = 'running';
          currentProgress = 0;
          currentVelocity = 0.0001;
          messageDisplay.textContent = 'Train in motion!';
        }
      });

      const MIN_VELOCITY = 0.00008;
      const MAX_VELOCITY = 200;
      const FRICTION = 0.000000000001;

      let prevTime = performance.now();

      function render() {
        const time = performance.now();
        const delta = time - prevTime;

        if (coasterState === 'running') {
          const tangent = curve.getTangentAt(currentProgress);
          currentVelocity += -tangent.y * 0.000003 * delta;
          currentVelocity *= (1 - FRICTION);
          currentVelocity = Math.max(MIN_VELOCITY, Math.min(currentVelocity, MAX_VELOCITY));

          currentProgress += currentVelocity;
          if (currentProgress > 1) {
            currentProgress = 0;
            messageDisplay.textContent = 'Train finished loop!';
            coasterState = 'stopped';
          }

          const position = curve.getPointAt(currentProgress);
          train.position.copy(position);

          const direction = curve.getTangentAt(currentProgress);
          const lookAt = new THREE.Vector3().copy(position).add(direction);
          train.lookAt(lookAt);
        }

        controls.update(delta * 0.001);
        renderer.render(scene, camera);
        prevTime = time;
      }

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      renderer.setAnimationLoop(render);
    </script>
  </body>
</html>

